<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1.5, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="Pick 5">
  <meta name="application-name" content="Pick 5">
  <meta name="theme-color" content="#333">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <link rel="icon" type="image/png" sizes="32x32" href="Pick5Logo.png">
  <link rel="icon" type="image/png" sizes="16x16" href="Pick5Logo.png">

  <link rel="apple-touch-icon" href="Pick5Logo.png">
  <link rel="apple-touch-icon" sizes="152x152" href="Pick5Logo.png">
  <link rel="apple-touch-icon" sizes="180x180" href="Pick5Logo.png">
  <link rel="apple-touch-icon" sizes="167x167" href="Pick5Logo.png">

  <link rel="shortcut icon" href="Pick5Logo.png">

  <link rel="manifest" href="manifest.json">

  <title>Pick 5</title>
  <style>
    html,
    body {
      background-color: black !important;
      margin: 0;
      padding: 0;
      overflow: hidden;
    
      
      left: 0;
      right: 0;
      
      width: 100%;
      height: 100%;
      font-family: Arial, sans-serif;
      overscroll-behavior: none;
    }

    * {
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-text-size-adjust: none;
      text-size-adjust: none;
    }

    input,
    textarea {
      font-size: 16px !important;
    }

    iframe {
      width: 100%;
      height: 100%;
      border: none;
      display: block;
      overflow: auto;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: black;
    }

    #install-banner {
      display: none;
      position: fixed;
      margin: 5px;
      border: 2px solid rgb(71, 143, 223);
      background: rgba(0, 0, 0, 0.85);
      bottom: 20px;
      left: 0;
      right: 0;
      color: white;
      text-align: center;
      padding: 5px;
      box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.2);
      z-index: 1000;
      width: max-content;
      margin: 0px auto;
    }

    #install-banner button {
      background-color: #478fdf;
      border: none;
      color: white;
      padding: 8px 16px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 16px;
      margin: 4px 2px;
      cursor: pointer;
      border-radius: 4px;
    }

    #ios-install-banner {
      display: none;
      position: fixed;
      margin: 5px;
      border: 2px solid rgb(71, 143, 223);
      background: rgba(0, 0, 0, 0.85);
      bottom: 1px;
      left: 0;
      right: 0;
      color: white;
      text-align: center;
      padding: 5px;
      box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.2);
      z-index: 1000;
      width: max-content;
      margin: 0px auto;
    }

    #ios-install-banner button {
      background-color: #478fdf;
      border: none;
      color: white;
      padding: 8px 16px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 16px;
      margin: 4px 2px;
      cursor: pointer;
      border-radius: 4px;
    }

    .notification {
      margin: 0 0 15px 0;
      font-size: 18px;
      font-weight: 700;
      width: 350px;
    }
    #preloader {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #333;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      overflow: hidden;
      background: linear-gradient(to top, #000 3%, rgba(0, 0, 0, 0.8) 5%, rgba(0, 0, 0, 0) 7%, rgba(0, 0, 0, 0) 50%, rgba(0, 0, 0, 0.8) 90%, #000 99%),
        url(https://img.freepik.com/premium-photo/3d-rendering-empty-Americans-football-field-with-stadium_493806-8391.jpg?semt=ais_hybrid);
      color: white;
      padding: 0px;
      background-attachment: fixed;
      background-repeat: round;
      background-size: cover;
    }

    #preloader-text {
      background: 50% 100% / 50% 50% no-repeat radial-gradient(ellipse at bottom, #478fdf, transparent, transparent);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      font-size: 7rem;
      /* font-family: "Source Sans Pro", sans-serif; */
      animation: reveal 3000ms ease-in-out forwards 200ms, glow 2500ms linear infinite 2000ms;
      font-weight: 900;
      white-space: nowrap;
      line-height: 1;
      text-align: center;
      position: relative;
    }
    #preloader-text::after {
      content: "";
      position: absolute;
      left: 50%;
      bottom: 10px;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(200, 200, 200, 0.6) 10%, rgba(200, 200, 200, 0.2) 50%, transparent);
      filter: blur(16px);
      opacity: 0.9;
      transform: translateX(-50%) scale(1);
      animation: smoke-rise 5s infinite ease-in-out;
      pointer-events: none;
}
    .pre-load-fade-out {
      opacity: 0;
      transition: opacity 7s ease-out;
      pointer-events: none;
    }

    @keyframes reveal {
      80% {
        letter-spacing: 8px;
      }

      100% {
        background-size: 300% 300%;
      }
    }

    @keyframes glow {
      40% {
        text-shadow: 0 0 8px #478fdf;
      }
    }
    @keyframes smoke-rise {
  0% {
    transform: translateX(-50%) translateY(0) scale(1);
    opacity: 0.9;
  }
  50% {
    opacity: 0.5;
  }
  100% {
    transform: translateX(-50%) translateY(-80px) scale(1.2);
    opacity: 0;
  }
}

    @media (max-width: 1100px) {

          html, body {
  margin: 0;
  padding: 0;
  width: 100vw;
  height: 100vh;
  background-color: black;
  overflow: hidden;
}
      
  iframe {
    position:fixed;
    top:0;
    left:0;
    right:0;
    bottom:0;
    padding:0;
    margin:0;
    overflow: auto;
    box-sizing:border-box;
    }
      
      .notification {
        width: -webkit-fill-available;
      }
      #ios-install-banner {
        width: width: -webkit-fill-available;
        margin: 0px 3px;
    }
      #install-banner {
        width: width: -webkit-fill-available;
        margin: 0px 3px;
      }
          #preloader {
              background: linear-gradient(to top, #000 3%, rgba(0, 0, 0, 0.8) 5%, rgba(0, 0, 0, 0) 28%, rgba(0, 0, 0, 0) 50%, rgba(0, 0, 0, 0.8) 101%, #000 75%), 
                url(https://www.shutterstock.com/image-illustration/3d-render-soccer-empty-stadium-600nw-2472453011.jpg);
        background-attachment: fixed;
        background-repeat: round;
        background-size: cover;
    }
      #preloader-text{
        padding-bottom: 10%;
      }
    }
    @media (orientation: portrait) {
  body {
    padding-top: env(safe-area-inset-top);
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
    box-sizing: border-box;
}
}

  </style>
</head>

<body>
  <div id="preloader">
    <div id="preloader-text">PICK 5</div>
    <button id="resetBtn" onclick="resetNotifications()" style="
                    position: fixed;
                    bottom: 20px;
                    right: 12px;
                    background-color: transparent;
                    color: #478fdf;
                    border: 1px solid #478fdf;
                    padding: 7px 7px;
                    border-radius: 4px;
                    font-weight: bold;
                    cursor: pointer;
                    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
                    z-index: 1001;
                    transition: all 0.3s ease;">Reset Notifications</button>
  </div>

  <div id="install-banner">
    <p style="margin: 5px;">Add to Home Screen for the best experience</p>
    <button id="install-button">Add</button>
    <button id="dismiss-button">Dismiss</button>
  </div>

  <div id="ios-install-banner"
    style="display: none; position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.85); color: white; padding: 10px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); z-index: 1001; text-align: left; max-width: 90%; font-family: Arial, sans-serif;">
    <button id="ios-install-close" style="position: absolute; top: 5px; right: 5px; background: #478fdf; border: 1px solid black; width: 24px; height: 24px; font-size: 20px; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0; line-height: 1; border-radius: 5px;">âœ•</button>
    <h3 style="margin: 0 0 10px 0; font-size: 18px; font-weight: bold; display: flex; align-items: center;">
      <img src="https://raw.githubusercontent.com/6630180REM/Pick5/refs/heads/main/Pick5Logo.png" alt="Pick 5 Logo" style="width: 30px; height: 30px; margin-right: 8px; vertical-align: middle;border: 1px solid white; border-radius: 8px;">Install 'Pick 5' on Your Device.
    </h3>
    <p style="margin: 0 0 10px 0; font-size: 14px;">To install this as an app on your device, follow the below
      instructions.</p>
    <p style="margin: 5px 0; font-size: 14px;">1. Tap on share <img src="https://static-00.iconduck.com/assets.00/ios-share-icon-1490x2048-h3vjhu9m.png" alt="Share icon" style="width: 16px; height: 16px; object-fit: contain; vertical-align: middle;filter: invert(100%);">
    </p>
    <p style="margin: 5px 0; font-size: 14px;">2. Select 'Add to Home Screen' <img src="https://static-00.iconduck.com/assets.00/plus-square-icon-2048x2048-h144q2yx.png" alt="Share icon" style="width: 16px; height: 16px; object-fit: contain; vertical-align: middle;filter: invert(100%);">
    </p>
    <p style="margin: 5px 0; font-size: 14px;">3. Click 'Add'</p>
    <!-- <div style="display: flex; justify-content: flex-end; margin-top: 0px;">
        <button id="ios-install-dismiss" style="background: #478fdf;border: none;color: white; padding: 5px 12px;text-align: center;text-decoration: none;display: inline-block;font-size: 16px;margin: 4px 2px;cursor: pointer;border-radius: 4px;">Dismiss</button>
    </div> -->
  </div>

  <iframe frameborder="0" scrolling="yes" allowfullscreen="yes" viewport-fit="cover"
    src="https://script.google.com/macros/s/AKfycbwuZM7KGKnS7jnpM2YN9W_AgTMqA0qJGw99K3MIUNxzI1tnh3YK76AhgeCfh2Wc7pTd/exec"></iframe>

<!--   <script src="https://www.gstatic.com/firebasejs/11.1.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.1.0/firebase-messaging-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.1.0/firebase-firestore-compat.js"></script> -->

    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-messaging-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-J8ZSHET5RJ"></script>
  
  <script>
    let messaging;
    let db;

async function resetNotifications() {
    // Get the button element for visual feedback
    const button = document.getElementById('resetBtn');

    // Change appearance when clicked
    button.style.backgroundColor = '#478fdf';
    button.style.color = 'white';
    button.textContent = 'Resetting...';

    if (!checkStorageAvailability()) {
        showSuccessMessage('Storage unavailable. Please check browser settings.');

        // Change button to indicate error
        button.style.backgroundColor = '#ff4d4d';
        button.textContent = 'Reset Failed';
        return;
    }

    console.log('Resetting notifications...');
    try {
        // Unregister all service workers
        const registrations = await navigator.serviceWorker.getRegistrations();
        for (let registration of registrations) {
            await registration.unregister();
            console.log('Service worker unregistered');
        }
        await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for cleanup
        if (messaging) {
            try {
                const token = await messaging.getToken().catch(err => {
                    console.log('No current token found:', err);
                    return null; // Handle case where no token exists
                });
                if (token) {
                    await messaging.deleteToken().catch(err => {
                        console.warn('Token deletion failed:', err);
                    });
                    console.log('Token deleted from FCM');
                } else {
                    console.log('No token to delete');
                }
                const deviceId = localStorage.getItem('deviceId');
                if (deviceId) {
                    const snapshot = await db.collection('devices')
                        .where('deviceId', '==', deviceId)
                        .get();
                    if (!snapshot.empty) {
                        const batch = db.batch();
                        snapshot.forEach(doc => {
                            const data = doc.data();
                            const updates = {};
                            if (data.activeTokens) {
                                Object.keys(data.activeTokens).forEach(t => {
                                    updates[`activeTokens.${t}`] = false;
                                });
                                batch.update(doc.ref, updates);
                            }
                        });
                        await batch.commit();
                        console.log('All tokens marked inactive in Firestore');
                    }
                }
            } catch (err) {
                console.error('Error processing token:', err);
            }
        }
        // Clear all notification-related local storage
        localStorage.removeItem('fcmToken');
        localStorage.removeItem('notificationPromptDismissed');
        localStorage.removeItem('notificationPermissionDenied'); // Clear any permission denial flag

        // Update button to indicate success
        button.style.backgroundColor = '#478fdf'; // Green color for success
        button.textContent = 'Reset Complete';

        // Check current permission state and act accordingly
        if (Notification.permission === 'denied') {
            showSuccessMessage('Notifications blocked. Enable in browser settings.');
        } else if (Notification.permission === 'granted') {
            // Even if granted, reset everything and force a new prompt
            showSuccessMessage('Notifications reset. Please reauthorize.');
            setTimeout(() => {
                console.log('Forcing reauthorization...');
                forceNotificationRePrompt();
            }, 1500);
        } else {
            // Default state: prompt should appear after reinitialization
            showSuccessMessage('Notifications reset. You will be prompted again.');
            setTimeout(() => {
                console.log('Reinitializing Firebase...');
                setupFirebaseAndNotifications();
            }, 1500);
        }

        // Make the button fade out after success
        setTimeout(function() {
            button.style.opacity = '0';
            // Remove from DOM after fade completes
            setTimeout(function() {
                button.style.display = 'none';
            }, 300); // Match this to the transition time in CSS
        }, 2500); // Give user time to see the success state

    } catch (err) {
        console.error('Reset failed:', err);
        showSuccessMessage('Failed to reset notifications. Try again.');

        // Change button to indicate error
        button.style.backgroundColor = '#ff4d4d'; // Red color for error
        button.textContent = 'Reset Failed';
    }
}

// Helper function to force a re-prompt
function forceNotificationRePrompt() {
    // Reinitialize Firebase and trigger the prompt
    setupFirebaseAndNotifications();
}

// Ensure storage check is defined
function checkStorageAvailability() {
    return !!(navigator.storage && window.indexedDB);
}

        function setupFirebaseAndNotifications() {
            // Firebase Configuration
            const firebaseConfig = {
                apiKey: "AIzaSyB5r_KL2eKVFd66VQU_5pznKrVHa9xzCfc",
                authDomain: "joespick5push.firebaseapp.com",
                projectId: "joespick5push",
                storageBucket: "joespick5push.firebasestorage.app",
                messagingSenderId: "783669343677",
                appId: "1:783669343677:web:d3a43a1a58b920ba9a4ed4",
                measurementId: "G-HNPLN4XZ44"
            };

            // Initialize Firebase (with check to prevent duplicate initialization)
            if (!firebase.apps || !firebase.apps.length) {
                firebase.initializeApp(firebaseConfig);
            }

            messaging = firebase.messaging();
            db = firebase.firestore();

if ('serviceWorker' in navigator) {
    const swPath = '/Pick5/firebase-messaging-sw.js';
    console.log('Service worker path:', swPath);

    console.log('Attempting to register service worker at:', swPath);

    navigator.serviceWorker.register(swPath)
        .then(registration => {
            console.log('Service Worker registered with scope:', registration.scope);
            initializeNotifications(registration);
        })
        .catch(error => {
            console.error('Service Worker registration failed:', error.message);
        });
} else {
    console.log('Service workers not supported');
}


            // Initialize notifications after service worker is registered
            function initializeNotifications(registration) {
                // Set up token refresh listener
                navigator.serviceWorker.addEventListener('message', event => {
                    if (event.data && event.data.type === 'tokenRefresh') {
                        console.log('Token refresh detected');
                        refreshToken();
                    }
                });

                // Function to request permission and get token
                function requestPermission() {
                    return new Promise((resolve, reject) => {
                        Notification.requestPermission()
                            .then(permission => {
                                if (permission === 'granted') {
                                    console.log('Notification permission granted.');
                                    messaging.getToken({
                                        vapidKey: 'BOM3KFfemC5lGnsF28N-_UGA7H9esoOm5gp0_Eg45HMqaMqviLx_bcAonVaZe-c0GwSFwfwe7-fJVP1n8h1iAAU',
                                        serviceWorkerRegistration: registration
                                    })
                                    .then(token => {
                                        console.log('Device token:', token);
                                        saveTokenToFirestore(token);
                                        resolve(token);
                                    })
                                    .catch(error => {
                                        console.error('Error getting token:', error);
                                        reject(error);
                                    });
                                } else {
                                    console.log('Notification permission denied.');
                                    localStorage.setItem('notificationPermissionDenied', 'true');
                                    reject(new Error('Permission denied'));
                                }
                            })
                            .catch(error => {
                                console.error('Error requesting permission:', error);
                                reject(error);
                            });
                    });
                }

                // Function to refresh token
                function refreshToken() {
                    messaging.getToken({
                        vapidKey: 'BOM3KFfemC5lGnsF28N-_UGA7H9esoOm5gp0_Eg45HMqaMqviLx_bcAonVaZe-c0GwSFwfwe7-fJVP1n8h1iAAU',
                        serviceWorkerRegistration: registration
                    }).then(refreshedToken => {
                        console.log('Token refreshed:', refreshedToken);
                        saveTokenToFirestore(refreshedToken);
                    }).catch(err => {
                        console.error('Unable to refresh token:', err);
                    });
                }

                // Show notification prompt
                function createNotificationPrompt() {
                    // Check if a prompt is already showing
                    if (document.getElementById('notification-prompt')) {
                        return;
                    }

                    const promptDiv = document.createElement('div');
                    promptDiv.id = 'notification-prompt';
                    promptDiv.style.cssText = `
                        position: fixed;
                        bottom: 50%;
                        left: 50%;
                        transform: translate(-50%, 50%);
                        background: rgba(0, 0, 0, 0.85);
                        color: white;
                        padding: 8px 8px;
                        border-radius: 10px;
                        box-shadow: rgba(0, 0, 0, 0.9) 0px 10px 13px;
                        text-align: center;
                        z-index: 1001;
                        font-family: Arial, sans-serif;
                        max-width: 90%;
                        width: max-content;
                        border: 2px solid rgb(71, 143, 223);
                        animation: fade-in 0.3s ease-in-out;
                    `;

                    promptDiv.innerHTML = `
                        <p class="notification">You'll receive notifications when Picks and Entry Form are available</p>
                        <div style="display: flex; justify-content: space-between; gap: 10px;width: 104px;margin: 0 auto;">
                            <button id="enable-notifications" style="background-color: #478fdf; color: white; border: none; padding: 10px 18px; border-radius: 4px; font-weight: bold; cursor: pointer; flex: 1;width: 104px;margin: 0 auto;">Ok</button>
                            <button id="decline-notifications" style="display: none; background-color: transparent; color: white; border: 1px solid white; padding: 10px 18px; border-radius: 4px; cursor: pointer; flex: 1;">Not Now</button>
                        </div>
                    `;

                    document.body.appendChild(promptDiv);

document.getElementById('enable-notifications').addEventListener('click', () => {
    promptDiv.remove();
    requestPermission()
        .then(() => {
            showSuccessMessage('Notifications enabled successfully!');
        })
        .catch(error => {
            console.error('Error enabling notifications:', error);
        });
});


                    document.getElementById('decline-notifications').addEventListener('click', () => {
                        promptDiv.remove();
                        localStorage.setItem('notificationPromptDismissed', Date.now());
                    });
                }

                // Save token to Firestore - UPDATED
async function saveTokenToFirestore(token, retries = 3) {
    if (!token) {
        console.error('No token provided to saveTokenToFirestore');
        return;
    }

    // Generate a device identifier
    const deviceId = localStorage.getItem('deviceId') || generateDeviceId();

    // Store deviceId for future use
    localStorage.setItem('deviceId', deviceId);

    const browserInfo = {
        name: /Chrome/i.test(navigator.userAgent) ? 'Chrome' : 
            /Safari/i.test(navigator.userAgent) ? 'Safari' : 
            /Firefox/i.test(navigator.userAgent) ? 'Firefox' : 
            /Edge/i.test(navigator.userAgent) ? 'Edge' : 'Other',
        userAgent: navigator.userAgent,
    };

const attemptSave = async (attempt) => {
    try {
        // Query existing device records
        const deviceQuery = await db.collection('devices')
            .where('deviceId', '==', deviceId)
            .get();

        if (!deviceQuery.empty) {
            // Device exists in database
            const deviceDoc = deviceQuery.docs[0];
            const oldData = deviceDoc.data();

            // Declare updateData before using it
            let updateData = {
                lastActive: firebase.firestore.FieldValue.serverTimestamp(),
                userAgent: browserInfo.userAgent,
                forceUpdate: Date.now() // Ensures Firestore registers an update
            };

            // Delete all existing tokens and activeTokens entries
            if (oldData.tokens) {
                Object.keys(oldData.tokens).forEach(oldTokenKey => {
                    updateData[`tokens.${oldTokenKey}`] = firebase.firestore.FieldValue.delete();
                });
            }
            if (oldData.activeTokens) {
                Object.keys(oldData.activeTokens).forEach(oldToken => {
                    updateData[`activeTokens.${oldToken}`] = firebase.firestore.FieldValue.delete();
                });
            }

            // Set the new token as the only active token
            updateData[`tokens.${browserInfo.name}`] = token;
            updateData[`activeTokens.${token}`] = true;

            // Log update data to check its structure
            console.log('Updating document:', deviceDoc.id);
            console.log('Update data:', updateData);

            // Update the device record
            await db.collection('devices').doc(deviceDoc.id).update(updateData);
            console.log('Device token updated successfully, old tokens deleted');

            // Fetch updated document to confirm `lastActive` change
            const updatedDoc = await db.collection('devices').doc(deviceDoc.id).get({ source: 'server' });
            console.log('Updated lastActive:', updatedDoc.data().lastActive);

        } else {
            // New device, create a record
            await db.collection('devices').add({
                deviceId: deviceId,
                platform: navigator.platform,
                tokens: { [browserInfo.name]: token },
                activeTokens: { [token]: true },
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                lastActive: firebase.firestore.FieldValue.serverTimestamp(),
                userAgent: browserInfo.userAgent
            });
            console.log('New device record created successfully');
        }

        // Store token in local storage
        localStorage.setItem('fcmToken', token);

        // Clean up duplicate tokens in the system
        await cleanupDuplicateTokens(token, deviceId);

    } catch (error) {
        console.error(`Attempt ${attempt} failed:`, error.message);
        if (attempt < retries) {
            console.log(`Retrying... (${attempt + 1}/${retries})`);
            await new Promise(resolve => setTimeout(resolve, 1000));
            await attemptSave(attempt + 1);
        } else {
            console.error('Max retries reached. Device save failed.');
        }
    }
};
    await attemptSave(1);
}
              

// Updated cleanupDuplicateTokens to delete tokens instead of deactivating
async function cleanupDuplicateTokens(currentToken, deviceId) {
    try {
        // Find all devices with this device ID
        const deviceQuery = await db.collection('devices')
            .where('deviceId', '==', deviceId)
            .get();

        // Only keep the last device record, delete others
        if (deviceQuery.size > 1) {
            // Sort by lastActive timestamp (newest first)
            const sortedDocs = deviceQuery.docs.sort((a, b) => {
                const timeA = a.data().lastActive ? a.data().lastActive.toMillis() : 0;
                const timeB = b.data().lastActive ? b.data().lastActive.toMillis() : 0;
                return timeB - timeA;
            });

            // Keep the first one (most recent), delete the rest
            const batch = db.batch();
            for (let i = 1; i < sortedDocs.length; i++) {
                batch.delete(sortedDocs[i].ref);
            }
            await batch.commit();
            console.log(`Cleaned up ${sortedDocs.length - 1} duplicate device records`);
        }

        // Get all devices with this token
        const allDevicesWithToken = await db.collection('devices')
            .where(`activeTokens.${currentToken}`, '==', true)
            .get();

        if (!allDevicesWithToken.empty) {
            const batch = db.batch();
            let updateCount = 0;

            allDevicesWithToken.forEach(doc => {
                const data = doc.data();
                // Only update devices that aren't the current one
                if (data.deviceId !== deviceId) {
                    batch.update(doc.ref, {
                        [`activeTokens.${currentToken}`]: firebase.firestore.FieldValue.delete(),
                        [`tokens.${Object.keys(data.tokens).find(key => data.tokens[key] === currentToken)}`]: firebase.firestore.FieldValue.delete()
                    });
                    updateCount++;
                }
            });

            if (updateCount > 0) {
                await batch.commit();
                console.log(`Deleted current token from ${updateCount} other devices`);
            }
        }
    } catch (error) {
        console.error('Error cleaning up tokens:', error);
    }
}

                // Generate consistent device ID - NEW
                function generateDeviceId() {
                    // Create a somewhat unique ID based on device characteristics
                    const deviceData = [
                        navigator.userAgent,
                        navigator.language,
                        screen.width,
                        screen.height,
                        new Date().getTimezoneOffset()
                    ].join('|');

                    // Create a hash of the device data
                    let hash = 0;
                    for (let i = 0; i < deviceData.length; i++) {
                        const char = deviceData.charCodeAt(i);
                        hash = ((hash << 5) - hash) + char;
                        hash = hash & hash; // Convert to 32bit integer
                    }
                    return 'device_' + Math.abs(hash);
                }

                // UPDATED: Check and show notifications
                function checkAndShowNotifications() {
    console.log('Checking notification state...');
    console.log('Current permission:', Notification.permission);
if (isDesktop()) {
        console.log('Desktop detected, skipping notification setup.');
        return;
    }
                  
    // Always prompt after reset, regardless of previous state
    const wasReset = !localStorage.getItem('fcmToken') && !localStorage.getItem('notificationPromptDismissed');

    if (Notification.permission === 'granted' && !wasReset) {
        // Normal flow: verify token
        const storedToken = localStorage.getItem('fcmToken');
        const storedDeviceId = localStorage.getItem('deviceId');

        if (storedToken) {
            messaging.getToken().then(currentToken => {
                if (currentToken !== storedToken) {
                    console.log('Token has changed, updating...');
                    saveTokenToFirestore(currentToken);
                } else {
                    console.log('Token still valid');
                    if (storedDeviceId) {
                        db.collection('devices')
                            .where('deviceId', '==', storedDeviceId)
                            .get()
                            .then(snapshot => {
                                if (!snapshot.empty) {
                                    const doc = snapshot.docs[0];
                                    const data = doc.data();
                                    if (!data.activeTokens || !data.activeTokens[currentToken]) {
                                        console.log('Token exists but not active, reactivating...');
                                        saveTokenToFirestore(currentToken);
                                    }
                                }
                            })
                            .catch(err => console.error('Error checking token status:', err));
                    }
                }
            }).catch(error => {
                // console.error('Error verifying token:', error);
                requestPermission();
            });
        } else {
            requestPermission();
        }
    } else {
        // Force prompt after reset or if permission is default/denied
        promptForPermission();
    }
}

function promptForPermission() {
    console.log('Prompting for permission...');
  if (isDesktop()) {
        console.log('Desktop detected, skipping notification prompt.');
        return;
    }
  
    if (Notification.permission === 'denied') {
        console.log('Notifications already denied');
    } else {
        const lastDismissed = localStorage.getItem('notificationPromptDismissed');
        const ONE_WEEK = 7 * 24 * 60 * 60 * 1000;

        // Skip timing check if recently reset
        if (!lastDismissed || (Date.now() - parseInt(lastDismissed)) > ONE_WEEK || !localStorage.getItem('fcmToken')) {
            // Function to trigger the prompt
            const triggerPrompt = () => {
                clearTimeout(promptTimeout); // Clear the timeout if it hasn't fired yet
                document.removeEventListener('click', userInteracted); // Remove click listener
                setTimeout(createNotificationPrompt, 1000); // Show prompt after 1-second delay
            };

            // Set up click interaction
            const userInteracted = () => {
                console.log('User clicked, triggering prompt early');
                triggerPrompt();
            };

            // Wait for either click or 10 seconds
            document.addEventListener('click', userInteracted, { once: true });
            const promptTimeout = setTimeout(() => {
                console.log('10 seconds elapsed, triggering prompt');
                document.removeEventListener('click', userInteracted); // Clean up click listener
                triggerPrompt();
            }, 6000); // 10 seconds

            // Initial delay of 2 seconds before starting the click/10-second logic
            setTimeout(() => {
                console.log('Starting prompt wait period (click or 10 seconds)');
            }, 2000);
        }
    }
}

                // Add styles for animations
                const styleSheet = document.createElement("style");
                styleSheet.textContent = `
                    @keyframes fade-in {
                        from { opacity: 0; }
                        to { opacity: 1; }
                    }
                    @keyframes fade-out {
                        from { opacity: 1; }
                        to { opacity: 0; }
                    }
                    @keyframes slide-in {
                        from { transform: translateX(100%); }
                        to { transform: translateX(0); }
                    }
                    @keyframes slide-out {
                        from { transform: translateX(0); }
                        to { transform: translateX(100%); }
                    }
                `;
                document.head.appendChild(styleSheet);

                // Start the notification flow
                checkAndShowNotifications();
            }
        }

        function showSuccessMessage(message) {
            const successDiv = document.createElement('div');
            successDiv.style.cssText = `
                position: fixed;
                bottom: 50%;
                left: 50%;
                transform: translate(-50%, 50%);
                width: fit-content;
                min-width: 200px;
                white-space: nowrap;
                z-index: 1010;
                background: rgba(0, 0, 0, 0.85);
                color: white;
                padding: 8px 8px;
                border-radius: 10px;
                box-shadow: rgba(0, 0, 0, 0.9) 0px 10px 13px;
                text-align: center;
                font-family: Arial, sans-serif;
                max-width: 90%;
                width: max-content;
                border: 2px solid rgb(71, 143, 223);
                animation: fade-in 0.5s ease-in-out;
            `;
            successDiv.textContent = message;
            document.body.appendChild(successDiv);
            setTimeout(() => {
                successDiv.style.animation = 'fade-out 0.3s ease-in-out';
                setTimeout(() => successDiv.remove(), 500);
            }, 5000);
        }

        // Call the function when the page is fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            const preloader = document.getElementById('preloader');
                  // preloader.classList.add("pre-load-fade-out");
            setTimeout(() => {
                preloader.style.display = 'none';
                setupFirebaseAndNotifications();
            }, 7000);
        });

        // PWA Install Prompt
        let deferredPrompt;

function isDesktop() {
    const userAgent = navigator.userAgent.toLowerCase();
    // Check for common desktop-specific keywords in userAgent
    const isDesktopUA = /windows nt|macintosh|linux/i.test(userAgent) && !/mobile|android|iphone|ipad|ipod/i.test(userAgent);
    // Optionally, check screen width (e.g., > 1024px for desktop)
    const isLargeScreen = window.innerWidth > 1024;
    return isDesktopUA && isLargeScreen;
}

function isAndroid() {
    return /Android/i.test(navigator.userAgent);
}

// Updated setupInstallPrompt function
function setupInstallPrompt() {
    const installBanner = document.getElementById('install-banner');
    const iosInstallBanner = document.getElementById('ios-install-banner');
    const installButton = document.getElementById('install-button');
    const dismissButton = document.getElementById('dismiss-button');
    const iosCloseButton = document.getElementById('ios-install-close');

    // If on desktop, hide both banners and exit
    if (isDesktop()) {
        installBanner.style.display = 'none';
        iosInstallBanner.style.display = 'none';
        return;
    }

    // If already installed (standalone mode), hide both banners
    if (isStandalone()) {
        installBanner.style.display = 'none';
        iosInstallBanner.style.display = 'none';
        return;
    }

    // Platform-specific handling for non-desktop devices
    if (isIOS()) {
        iosInstallBanner.style.display = 'block'; // Show iOS banner with instructions

        // Close button (X): Hide the banner
        iosCloseButton.addEventListener('click', () => {
            iosInstallBanner.style.display = 'none';
        });
    } else {
        // Android/PC: Show install banner when beforeinstallprompt fires
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            installBanner.style.display = 'block';
        });
    }

    // Install button for Android/PC
    installButton.addEventListener('click', () => {
        if (deferredPrompt) {
            installBanner.style.display = 'none';
            deferredPrompt.prompt();
            deferredPrompt.userChoice.then((choiceResult) => {
                if (choiceResult.outcome === 'accepted') {
                    console.log('User accepted the install prompt');
                } else {
                    console.log('User dismissed the install prompt');
                }
                deferredPrompt = null;
            });
        }
    });

    // Dismiss button for Android/PC banner
    dismissButton.addEventListener('click', () => {
        installBanner.style.display = 'none';
    });
}

// Run when page loads
document.addEventListener('DOMContentLoaded', () => {
    setupInstallPrompt();
  gtag('event', 'app_mode', {
        'event_category': 'User Engagement',
        'event_label': isStandalone() ? 'Standalone App' : 'Browser',
        'value': isStandalone() ? 1 : 0
    });
});

// Platform detection functions (unchanged)
function isIOS() {
    return /iPhone|iPad|iPod/i.test(navigator.userAgent);
}

function isStandalone() {
    return window.matchMedia('(display-mode: standalone)').matches;
}

// function resizeIframe() {
//     var iframe = document.querySelector("iframe");
//     if (iframe) {
//         // Debounce the resize to prevent excessive updates
//         let timeout;
//         clearTimeout(timeout);
//         timeout = setTimeout(() => {
//             // Use screen dimensions as fallback
//             const height = window.innerHeight || document.documentElement.clientHeight || screen.height;
//             const width = window.innerWidth || document.documentElement.clientWidth || screen.width;

//             iframe.style.height = height + "px";
//             iframe.style.width = width + "px";

//             // Remove any potential scrollbars
//             iframe.style.border = "none";
//             iframe.style.margin = "0";
//             iframe.style.padding = "0";
//         }, 100);
//     }
// }

// // Event listeners
// window.addEventListener("resize", resizeIframe);
// window.addEventListener("load", resizeIframe);
// window.addEventListener("orientationchange", resizeIframe);

// // Media query listener
// if (window.matchMedia) {
//     const mediaQuery = window.matchMedia("(orientation: portrait)");
//     mediaQuery.addEventListener("change", resizeIframe);
// }

// // Initial call
// resizeIframe();  

  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-J8ZSHET5RJ');
   
  </script>
</body>

</html>
